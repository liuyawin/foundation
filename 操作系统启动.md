# 启动
DISK: 存放OS和BootLoader；  
BIOS： 基本I/O处理系统;  

**BIOS**:计算机加电之后BIOS将进行自检（POST），然后将BootLoader从硬盘中加载到内存中，BootLoader掌握CPU控制权。    
**BootLoader**： 将操作系统的代码和数据从硬盘加载到内存中，跳到操作系统的起始地址，将控制权交给操作系统。  

## 中断、异常、系统调用
**系统调用**（来源应用程序）：应用程序主动向操作系统发出服务请求。  
**异常**（来源于不良的应用程序）：非法指令或者其他坏的处理状态。  
**中断**（来源于外设）：来自不同状态的计时器和网络中断。  
操作系统利用这三者与外设和应用程序打交道。用中断和I/O来处理外设，用系统调用和异常为应用程序提供服务和支持。三者区别：  
1.来源：系统调用来源于应用程序请求操作系统提供服务，异常来源于应用程序意想不到的行为，中断来源于外设。   
2.处理时间：中断是异步的，异常是同步的，系统调用是同步或异步的。   
3.响应状态：中断是持续的，对用户应用程序是透明的；异常会杀死或重新执行意想不到的应用程序指令；系统调用则是等待服务完成之后就继续执行。

为什么应用程序不能直接访问外设而要通过操作系统？  
1.在计算机运行中，内核是被信任的第三方；  
2.只有内核可以执行特权指令；  
3.为了方便应用程序。  
    
#### 中断的处理过程：    
分为硬件的处理过程和软件的处理过程。对应不同编号的中断的服务例程有不同的地址。操作系统收到中断之后，就会查找中断表，找到对应的服务例程的起始地址，转跳到那里开始执行。    
硬件：设置中断标记。1.将内部、外部事件这只中断标记；2.中断事件的ID。    
软件，即操作系统：1.保存当前状态；2.中断服务处理程序；3.中断完成后清除中断标记；4.恢复之前保存的处理状态。    
   
#### 异常的处理过程：    
异常也有异常编号。产生异常时，操作系统先保存现场，再根据异常编号进行相应的处理（杀死产生了异常的程序后者重新执行异常指令），最后恢复现场。    
#### 系统调用    
例子：标准C语言库中，应用程序调用printf()时，会触发系统调用write()，write系统调用会带一些参数，指定显示字符串的设备以及字符串的内容。操作系统在获取参数之后会直接访问对应的设备，让对应的设备将字符串显示出来。这整个过程由操作系统而非应用程序完成，应用程序只需要发出请求。操作系统完成处理之后就会返回一个成功或者失败，应用程序可以继续之后的工作。   
应用程序访问系统调主要是通过高层次的API接口，而不是直接进行系统调用。    
系统调用在执行时间上的开销超过程序调用，但是它更加安全。   
    
# 内存
操作系统如何管理物理内存？    
计算机体系结构主要包括CPU、内存和I/O外设三个部分。    
内存的层次结构：  

微处理器（CPU寄存器=>一级缓存=>二级缓存）     
           ||  
           ||  
          主存   
           ||    
           ||（交换/分页）    
     磁盘（虚拟内存）   
    
从上到下容量越来越大，速度越来越慢。     
   
为了管理内存，操作系统需要完成四项工作：    
* 抽象：逻辑地址空间；    
* 保护：独立地址空间；   
* 共享：访问相同内存；    
* 虚拟化：更多的地址空间。 

在操作系统中管理内存的不同方法：    
* 程序重定位   
* 分段   
* 分页
* 虚拟内存   
* 按需分页虚拟内存    

### 地址空间及地址生成    
**地址空间**   
* 物理地址空间：硬件直接对应的地址空间；
* 逻辑地址空间：一个运行的程序所拥有的内存范围。   
   
两者之间如何建立对应关系？     
逻辑地址空间最终是落在物理地址空间上的。    
操作系统建立逻辑地址到物理地址之间的映射。   
   
操作系统还要保证应用程序访问的内存地址是合法的。实际上是一个地址的安全检测的过程。    

## 内存分配
**连续内存分配**     
* 内存碎片问题    
内存碎片是指不能被使用的空闲内存。分为外部碎片（在分配单元间的未使用内存）和内部碎片（在分配单元中的未使用内存）。

分区的动态分配策略：   
* 首次适配：为了分配n字节，使用第一个比n大的可用空闲块。
* 最优适配：为了分配n字节，使用比n大的最小可用空间。
* 最差适配：为了分配n字节，使用比n大的最大可用空间。    

**压缩式与变换式碎片整理**    
压缩式：将碎片挪到一起；    
变换式：将空闲块移动到虚拟内存（磁盘）。    

**非连续内存分配**
优点：一个程序的物理内存可以是非连续的；更好的内存利用和管理；允许共享代码和数据；支持动态加载和动态链接。


# 虚拟内存
老技术
* 覆盖技术：为了在较小的内存中运行较大的程序。原理是把程序按照其自身的逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后顺序来运行。增加了程序员的负担。    
* 交换技术：多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源。方法1.将暂时不能运行的程序送到内存外，从而获得空闲的内存空间；2.操作系统将一个进程的整个地址空间内容保存到外存中，从而将外存中的某个进程的地址空间读入到内存中。换入换出内容的大小为整个程序的地址空间。增加了处理器的开销。        

**虚拟内存管理技术**    
目标：
* 像覆盖技术一样，不是把程序的所有内容都放在内存中，因而能够运行比当前空闲内存还要大的程序。但要做得更好，由操作系统自己完成，无需程序员干涉；   
* 像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但要做得更好，只对进程的部分内容在内存和外存之间进行交换。    

程序的局部性原理：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址分别局限于一定区域。这可以表现为：
1. 时间局部性：一条指令的一次和下一次执行、一个数据的访问和下一次访问都集中在一个较短的时期内；    
2. 空间局部性：当前指令和邻近的几条指令、当前访问的数据和邻近的几个数据都几种在一个较小的区域内。    

如果程序具备这两个局部性，则说明它的局部性很好，执行效率也相应很高。    

实现    
可以在页式或段式内存管理的基础上实现：
* 在装入程序时，不必将其全部装入到内存，而只需将当前需要执行的部分页面或段装入内存，就可以让程序开始执行；    
* 在程序执行过程中，如果需要执行的指令或访问的数据尚未在内存中（称为缺段或缺页），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；    
* 另一方面，操作系统将内存中暂时不用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段。     

特征：   
* 大的用户空间
* 只需要进行部分交换
* 物理内存分配不连续，虚拟地址空间的使用也不连续。
     
# 进程
定义：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。    
一个进程应该包括：   
* 程序的代码
* 程序处理的数据
* 程序计数器中的值，指示下一条将要执行的指令
* 一组通用的寄存器的当前值，堆、栈
* 一组系统资源（如打开的文件）

总之，进程包含了正在运行的一个程序的所有信息。   
    
程序与进程的关系：
* 程序是产生进程的基础。
* 程序的每次运行构成不同的进程。
* 进程是程序功能的体现。
* 通过多次执行，一个程序可以对应多个进程；通过调用关系，一个进程可以包括多个程序。 

程序与进程的区别：  
* 进程是动态的，程序是静止的：程序是有序代码的集合，进程是程序的执行，进程有核心态/用户态。
* 进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可以长久保存。   
* 进程和程序的组成不同：进程组成包括程序、数据和进程控制块（即进程状态信息）。

进程的特点：
* 动态性：可以动态的创建、结束进程；
* 并发性：进程可以被独立调度并占用处理机运行。并发是指在一个较短的时间段内执行多个进程，给人造成一种同时执行的错觉；并行是指在同一时刻执行多个进程。单核CPU是无法并行的；
* 独立性：不同进程的工作互不影响；
* 制约性：因访问共享数据/资源或进程间同步而产生的相互制约。  

进程控制块（PCB）：是描述进程的数据结构。每一个进程都有一个进程控制块，由操作系统进行管理。     
   
进程的生命周期：进程创建，进程运行，进程等待，进程唤醒，进程结束。    
   
引起进程创建的三个主要事件：
* 系统初始化时
* 用户请求创建一个新的进程
* 正在运行的进程执行了创建进程的系统调用

进程运行：内核选择一个就绪的进程，让它占用处理机并运行。  


进程等待（阻塞）的情况：
* 请求并等待无法马上完成的系统服务；
* 启动某种无法马上完成的操作；
* 需要的数据没有到达。
    
进程只能由自己阻塞。    
   
进程唤醒：
* 被阻塞进程需要的资源可被满足；
* 被阻塞进程等待的事件到达；
* 将该进程的PCB茶道就绪队列。

进程只能被别的进程或操作系统唤醒。    
    
进程退出：
* 正常退出（自愿的）
* 错误退出（自愿的）
* 致命错误（强制性的）
* 被其他进程杀死（强制性的）

进程的变化模型：运行态、就绪态、阻塞态三个状态之间的转换。       
   
进程的挂起：进程在挂起状态时，意味着进程没有占用内存空间。处在挂起状态的进程映像在磁盘上。    
挂起的状态：
* 阻塞挂起状态：进程在外存并等待某事件的出现
* 就绪挂起状态：进程在外存，但只要进入内存，即可运行。   

与挂起相关的状态转换：
* 阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进入这种转换，以提交新进程或运行就绪进程；
* 就绪到就绪挂起：当有高优先级阻塞（系统任务会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级进程；
* 运行到就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态。
* 阻塞挂起到就绪挂起：当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起的进程。该过程在外存中进行。
解挂/激活：将一个进程从外存转到内存，可能有以下两种情况：
* 就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换
* 阻塞挂起到阻塞：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事情）进程转换为阻塞进程。
     
进程通过状态队列来进行管理：
* 由操作系统来维护一组队列，用来表示系统中所有进程的当前状态
* 不同状态分别用不同队列表示（就绪队列、各种不同类型的阻塞队列）
* 每个进程的PCB都根据它的状态加入到不同队列中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。   

   
