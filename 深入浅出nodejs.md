**为什么叫node**？      
Node发展成为一个强制不共享任何资源的单线程、单进程系统，包括十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目标也是成为一个构建快速、可伸缩的网络应用平台。它自身非常简单，通过通信协议来组织许多Node，非常容易通过扩展来达到构建大型网络应用的目的。每一个Node进程都构成这个网络应用中的一个节点，这是它名字所含意义的真谛。    
      
**Node的特点**：    
* 异步I/O    
* 事件驱动与回调函数
* 单线程    
* 跨平台     
       
# 模块机制    
CommonJS对模块的定义分为**模块引用**、**模块定义**和**模块标识**三个部分。    
1. 模块引用     
模块引用方式为：var math = require('math');    
2. 模块定义    
对应引用功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的导出出口。在模块中还存在一个module对象，代表模块本身，exports是module的属性。在node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式。    
3. 模块标识    
模块标识实际就是传给require()的参数，它必须是符合小驼峰命名的字符串，可以使相对路径或绝对路径，可以没有文件后缀名js。     
      
在Node中引入模块需要经过以下三个步骤：    
1. 路径分析    
2. 文件定位    
3. 编译执行    
    
Node中的模块分为两类：一类是Node提供的模块，称为**核心模块**；一类是用户自己编写的模块，称为**文件模块**。     
**核心模块**在Node源代码的编译过程中被编译成了二进制文件。在Node启动时，部分核心模块就被直接加载进内存中，所以这部分模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析时优先判断，所以它加载的速度是最快的。       
**文件模块**则是动态加载的，需要完整的路径分析、文件定位和编译执行，其速度比核心模块慢。     
      
Node会对引用过的模块进行缓存，以减少二次引用的开销。它缓存的是编译和执行之后的对象。Node加载文件的优先级顺序为：缓存=>核心模块=>文件模块。     
     
## 路径分析和文件定位    
Node中的模块标识符分为以下几类：    
* 核心模块，如fs，http，path等    
* .或..开始的相对路径文件模块    
* /开始的绝对路径模块     
* 非路径形式的文件模块，如自定义的connect模块     
     
1. 核心模块    
核心模块的加载仅次于缓存，试图加载一个与核心模块标识符相同的自定义模块是不会成功的。    
2. 路径形式的文件模块    
以.、..或/开始的标识符，都被当做文件模块处理。在路径分析时，require()方法先将其转化为真实路径，并以真实路径为索引，将便已执行后的结果放到缓存中，使其二次加载更快。    
3. 自定义模块      
它是一种特殊的文件模块，可能是一个文件或者包的形式。（就是用npm引进来的那一部分模块）      
模块路径的生成规则为：    
* 当前文件目录下的node_modules目录     
* 父目录下的node_modules目录     
* 父目录的父目录下的node_modules目录      
* 沿着路径逐级向上递归，直到根目录     
      
在标识符不包含扩展名的情况下，Node会按照.js、.json、.node的次序补足扩展，依次尝试。     
            
若分析标识符得到的是一个目录，Node会将目录作为一个包来处理：    
* 首先在该目录下查找package.json文件，通过JSON.parse()解析出包的描述对象，从中取出main指向的文件进行定位。
* 若main指向文件名错误，或package.json文件不存在，则将index作为默认文件名，依次查找index.js、index.json、index.node。     
* 若还不成功，则自定义模块进入下一个模块进行查找。如果模块路径数组遍历完毕依然没有找到目标文件，会抛出一个查找失败的异常。       
      
## 模块编译     
Node对于不同扩展名的文件采取不同的载入方法：    
* .js：通过fs模块同步读取文件后编译执行。     
* .node：这是C/C++编写的扩展模块，通过dlopen()方法加载最后编译生成的文件。   
* .json：通过fs同步读取文件后，用JSON.parse()解析返回结果。    
* 其余扩展名：当做.js文件处理。      
     
每编译成功一个文件，都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入性能。      
在对js文件的编译过程中，Node对获取的js文件内容进行了头尾包装，代码如下：  
```
(function(exports, require, module, __filename, __dirname){
    var math = require('math');
    exports.are = function(r){
        return Math.PI * r * r;
    }
});
```   
这是为什么每个模块都有exports, require, module, __filename, __dirname变量，而且每个模块之间会有作用域隔离。    
      
核心模块和文件模块的调用关系：    
1. 核心模块分为JavaScript核心模块和C/C++内建模块。    
其中C/C++内建模块属于最底层的模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。可以使用process.binding()直接调用C/C++内建模块，但是不推荐。     
JavaScript核心模块主要扮演两类职责：一是作为C/C++内建模块的封装和桥接层，供文件模块调用；而是纯粹的功能模块，不需要跟底层打交道，但又十分重要。     
2. 文件模块通常由第三方编写，包括普通JavaScript模块和C/C++扩展模块（.node），主要调用方向为普通JavaScript模块调用扩展模块。     
    
## 包与npm    
Node对CommonJS模块规范的实现，一定程度上解决了变量依赖、依赖关系等代码组织性问题，而包的出现，则是在模块的基础上进一步组织JavaScript代码。     
```
                                    包
                        -----------------------------
                        |                  module    |
                        |                            |
   module  <-require()--| output module    module    |
                        |                            |
                        |                  ...       |
                        |____________________________|              

```    
    
**包的结构**。符合CommonJS规范的包目录应该包含如下文件：package.json，bin，lib，doc，test。     
     
# 异步I/O    
**为什么用异步I/O**？      
1. 从用户体验的角度，浏览器中JavaScript在单线程上执行，而且与UI渲染共用一个线程。这意味着JavaScript执行时UI渲染线程是停滞的。而网页在获取网页资源时，若通过同步方式，则JavaScript必须等待资源完全从服务器端获取之后才能执行，这一过程中UI渲染也会阻塞，不响应用户交互行为。采用异步可以避免这个问题，将响应时间由M+N转化为max(M, N)。     
2. 从资源分配的角度，多线程虽然能够提高CPU利用率，但是它的代价在于创建线程和执行线程上下文切换的开销比较大，在复杂业务中，还面临死锁、线程同步等问题。而单线程同步I/O的进行会让后续任务等待，造成资源不能被更好的利用。Node利用单线程远离死锁、状态同步等问题，利用异步I/O让单线程远离阻塞，能更好的利用CPU。   
    
**异步I/O与非阻塞I/O**    
操作系统对于I/O有两种方式：阻塞和非阻塞。阻塞操作的特点是调用之后必须等到系统内核层面完成所有操作后，调用才结束，而非阻塞I/O在调用后会立即返回。非阻塞I/O返回之后，CPU时间片可以用来处理其他事物，以提升性能。      
非阻塞I/O的问题在于如何知道I/O已经完成对数据的获取，应用程序可以反复调用I/O操作来确认是否完成，这种方式叫轮询。     
      
理想的异步I/O应该是程序发起非阻塞调用，无需经过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需要在I/O完成后通过信号或回调函数将数据传递给应用程序即可。      
     
**系统的异步I/O**    
Windows和*nix分开实现，Windows采用IOCP，*nix采用自定义的线程池。通过libuv作为抽象封装层，使得所有平台兼容层的判断都是在这一层完成的。       

**Node中的异步I/O**主要包括四个要素：事件循环、观察者、请求对象和I/O线程池。    
1. 事件循环    
在进程启动时，Node会创建一个类似于while(true)的循环，每执行一次循环体的过程称为一个Tick。每个Tick的过程就是查看是否有事件待处理。如果有，就取出事件执行相应的回调，然后进入下一个循环；如果不再有事件需要处理，就退出进程。     
2. 观察者    
观察者主要用于判断是否有事件需要处理。每个事件循环中有一个或多个观察者，判断是否有事件要处理的过程就是向这些观察者询问是否有事件要处理。        
3. 请求对象     
从JavaScript发起调用到内核执行完I/O操作的过渡过程中存在一个中间产物，称为请求对象。**从JavaScript调用Node核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用是Node里的经典调用方式**。例如在Windows读取文件操作中，会在libuv层创建一个FSReqWrap请求对象，从JavaScript层传入的参数和当前方法搜封装在这个请求对象中，而回调函数则在该对象的oncomplete_sym属性上。对象包装完毕之后，调用QueueUserWorkItem()方法将这个对象推入线程池中等待执行，然后JavaScript调用立即返回。至此，由JavaScript层面发起的异步调用的第一阶段结束，JavaScript线程继续执行当前任务的后续操作。      
4. 执行回调     
线程池中的I/O操作执行完毕之后，会将结果存储在req->result属性上，然后调用PostQueueCompletionStatus()方法通知IOCP当前对象操作已完成，并将线程池归还。事件循环中的观察者在Tick执行中会调用IOCP相关的GetQueueCompletionStatus()方法检查线程池中是否有执行完成的请求，如果有，会将请求对象加到I/O观察者队列中，然后将其当做事件进行处理。    
I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，并执行调用。至此，整个异步I/O流程全部结束。      
       
非I/O的异步API：setTimeout()、setInterval()、setImmediate()和process.nextTick()。      
```
process.nextTick(fucntion(){
    console.log('nextTick...');
});

setImmediate(function(){
    console.log('setImmediate...');
});

console.log('Normal..');
```   
可以看到打印的顺序为：‘Normal...’，‘nextTick...’，‘setImmediate...’。这说明process.nextTick()执行回调的优先级要高于setImmediate()。      
      
